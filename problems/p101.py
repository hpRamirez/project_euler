#coding: UTF-8
#If we are presented with the first k terms of a sequence it
#is impossible to say with certainty the value of the next
#term, as there are infinitely many polynomial functions
#that can model the sequence.
#
#As an example, let us consider the sequence of cube
#numbers. This is defined by the generating function,
#u_n = n^3: 1, 8, 27, 64, 125, 216, ...
#
#Suppose we were only given the first two terms of this
#sequence. Working on the principle that "simple is best" we
#should assume a linear relationship and predict the next
#term to be 15 (common difference 7). Even if we were
#presented with the first three terms, by the same principle
#of simplicity, a quadratic relationship should be assumed.
#
#We shall define OP(k, n) to be the nth term of the optimum
#polynomial generating function for the first k terms of a
#sequence. It should be clear that OP(k, n) will accurately
#generate the terms of the sequence for n ≤ k, and
#potentially the first incorrect term (FIT) will be OP(k,
#k+1); in which case we shall call it a bad OP (BOP).
#
#As a basis, if we were only given the first term of
#sequence, it would be most sensible to assume constancy;
#that is, for n ≥ 2, OP(1, n) = u1.
#
#Hence we obtain the following OPs for the cubic sequence:
#
#OP(1, n) = 1 1, 1, 1, 1, ...
#OP(2, n) = 7n − 6 1, 8, 15,...
#OP(3, n) = 6n^2 − 11n + 6 1, 8, 27, 58, ...
#OP(4, n) = n^3 1, 8, 27, 64, 125, ...
#
#Clearly no BOPs exist for k ≥ 4.
#
#By considering the sum of FITs generated by the BOPs
#(indicated in red above), we obtain 1 + 15 + 58 = 74.
#
#Consider the following tenth degree polynomial generating
#function:
#
#u_n = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9
#+ n^10.
#Find the sum of FITs for the BOPs.

from utils import Utils
u_ = Utils()
m, val = u_.binom(11,11)

def u(n):
    return n ** 10 - n ** 9 + n ** 8 - \
        n ** 7 + n ** 6 - n ** 5 + \
        n ** 4 - n ** 3 + n ** 2 - \
        n + 1
        
U = [u(j) for j in range(1, 12)]

def fit(n):
    l = [((-1) ** (p + (n % 2))) * 
        m[n][p - 1] * U[p - 1] for p in range(1, n + 1)]
    return sum(l)

def p101():
    """
        Turns out that after some algebraic manipulation
        with the formula for the interpolation polynomial
        (http://en.wikipedia.org/wiki/Polynomial_interpolation),
        we found the following formula for BOP(k):

        BOP(k) = \sum_1^l{(-1)^{l + r}{k \choose {l - 1}}u_l},
        where n \equiv r \pmod 2, so, it was just a matter
        of implementing the sum:
    """
    print sum([fit(l) for l in range(1, len(U))])

u_.exec_time(p101)